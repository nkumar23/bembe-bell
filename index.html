<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bembe Bell Pattern</title>
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-deep: #1a1410;
      --bg-warm: #2d2420;
      --bg-panel: #3d322a;
      --wood-light: #8b7355;
      --wood-mid: #6b5344;
      --cream: #f5e6d3;
      --cream-dim: #c4b5a2;
      --accent-orange: #e85d24;
      --accent-gold: #d4a056;
      --accent-ember: #ff6b35;
      --hit-glow: #ffaa33;
      --group-3: #4a9e8c;
      --group-4: #9e6b4a;
      --group-both: #8a7a9e;
      --charleston: #c45c8a;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: var(--bg-deep);
      font-family: 'DM Mono', monospace;
      color: var(--cream);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1.5rem;
      background-image:
        radial-gradient(ellipse at 30% 20%, rgba(139, 115, 85, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 80%, rgba(232, 93, 36, 0.05) 0%, transparent 40%),
        url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      background-blend-mode: normal, normal, overlay;
    }

    .container {
      max-width: 520px;
      width: 100%;
    }

    header {
      text-align: center;
      margin-bottom: 1.5rem;
    }

    h1 {
      font-family: 'Instrument Serif', serif;
      font-size: 2.5rem;
      font-weight: 400;
      font-style: italic;
      color: var(--cream);
      letter-spacing: -0.02em;
      text-shadow: 0 2px 20px rgba(232, 93, 36, 0.3);
    }

    .subtitle {
      font-size: 0.7rem;
      color: var(--cream-dim);
      letter-spacing: 0.2em;
      text-transform: uppercase;
      margin-top: 0.4rem;
    }

    /* Circular Sequencer */
    .sequencer-container {
      position: relative;
      width: 280px;
      height: 280px;
      margin: 0 auto 1.5rem;
    }

    @media (max-width: 400px) {
      .sequencer-container {
        width: 260px;
        height: 260px;
      }

      .beat-marker {
        width: 24px;
        height: 24px;
        font-size: 0.5rem;
      }
    }

    .sequencer-ring {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background:
        radial-gradient(circle at 50% 50%, var(--bg-panel) 0%, var(--bg-warm) 100%);
      box-shadow:
        inset 0 4px 20px rgba(0,0,0,0.5),
        0 0 0 3px var(--wood-mid),
        0 0 0 6px var(--bg-deep),
        0 0 0 8px var(--wood-light),
        0 8px 32px rgba(0,0,0,0.6);
    }

    .center-display {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
    }

    .tempo-display {
      font-family: 'Instrument Serif', serif;
      font-size: 3rem;
      font-style: italic;
      color: var(--cream);
      line-height: 1;
      text-shadow: 0 0 30px rgba(255, 170, 51, 0.4);
    }

    .tempo-label {
      font-size: 0.6rem;
      color: var(--cream-dim);
      letter-spacing: 0.15em;
      text-transform: uppercase;
    }

    .beat-marker {
      position: absolute;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: var(--bg-deep);
      border: 2px solid var(--wood-mid);
      transform: translate(-50%, -50%);
      transition: all 0.1s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.55rem;
      color: var(--cream-dim);
    }

    .beat-marker.hit {
      background: var(--wood-light);
      border-color: var(--accent-gold);
    }

    .beat-marker.active {
      background: var(--accent-orange);
      border-color: var(--accent-ember);
      box-shadow:
        0 0 20px var(--hit-glow),
        0 0 40px rgba(255, 107, 53, 0.5);
      transform: translate(-50%, -50%) scale(1.3);
    }

    .beat-marker.accent-3 {
      box-shadow: inset 0 0 0 2px var(--group-3);
    }

    .beat-marker.accent-4 {
      box-shadow: inset 0 0 0 2px var(--group-4);
    }

    .beat-marker.accent-3.accent-4 {
      box-shadow: inset 0 0 0 2px var(--group-both);
    }

    .beat-marker.charleston-hit {
      border-color: var(--charleston);
      border-width: 3px;
    }

    /* Group arc indicators */
    .group-arcs {
      position: absolute;
      inset: -12px;
      pointer-events: none;
    }

    .group-arc {
      fill: none;
      stroke-width: 3;
      stroke-linecap: round;
      opacity: 0.5;
      transition: opacity 0.3s ease;
    }

    .group-arc.group-3 { stroke: var(--group-3); }
    .group-arc.group-4 { stroke: var(--group-4); }

    /* Controls Panel */
    .controls {
      background: var(--bg-panel);
      border-radius: 16px;
      padding: 1.25rem;
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.05),
        0 4px 20px rgba(0,0,0,0.4);
      border: 1px solid var(--wood-mid);
    }

    .control-section {
      margin-bottom: 1rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid rgba(107, 83, 68, 0.5);
    }

    .control-section:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }

    .section-header {
      font-size: 0.65rem;
      color: var(--accent-gold);
      letter-spacing: 0.15em;
      text-transform: uppercase;
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .section-header::after {
      content: '';
      flex: 1;
      height: 1px;
      background: linear-gradient(to right, var(--wood-mid), transparent);
    }

    .control-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
      flex-wrap: wrap;
    }

    .control-row:last-child {
      margin-bottom: 0;
    }

    .control-row.transport-row {
      flex-wrap: nowrap;
    }

    .knobs-group {
      display: flex;
      gap: 0.5rem;
      flex-shrink: 0;
    }

    @media (max-width: 480px) {
      .control-row.transport-row {
        flex-wrap: wrap;
        justify-content: center;
        gap: 1rem;
      }

      .knobs-group {
        width: 100%;
        justify-content: center;
        gap: 1.5rem;
      }

      .slider-container {
        order: 2;
        width: 100%;
      }

      .play-btn {
        order: 1;
      }

      .knob-container {
        flex-shrink: 0;
      }

      .knob {
        width: 55px;
        height: 55px;
      }
    }

    .control-label {
      font-size: 0.65rem;
      color: var(--cream-dim);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      min-width: 55px;
      flex-shrink: 0;
    }

    /* Play Button */
    .play-btn {
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: linear-gradient(145deg, var(--accent-orange), #c44d1a);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow:
        0 4px 15px rgba(232, 93, 36, 0.4),
        inset 0 1px 0 rgba(255,255,255,0.2);
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .play-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 25px rgba(232, 93, 36, 0.5), inset 0 1px 0 rgba(255,255,255,0.2);
    }

    .play-btn:active { transform: scale(0.98); }

    .play-btn svg {
      width: 22px;
      height: 22px;
      fill: var(--cream);
    }

    .play-btn .pause-icon { display: none; }
    .play-btn.playing .play-icon { display: none; }
    .play-btn.playing .pause-icon { display: block; }

    /* Sliders */
    .slider-container {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .slider {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: var(--bg-deep);
      border-radius: 3px;
      outline: none;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(145deg, var(--wood-light), var(--wood-mid));
      cursor: pointer;
      border: 2px solid var(--accent-gold);
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: transform 0.1s ease;
    }

    .slider::-webkit-slider-thumb:hover { transform: scale(1.1); }

    .slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(145deg, var(--wood-light), var(--wood-mid));
      cursor: pointer;
      border: 2px solid var(--accent-gold);
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    .slider-bounds {
      font-size: 0.6rem;
      color: var(--cream-dim);
      min-width: 24px;
      text-align: center;
    }

    .slider-value {
      font-size: 0.7rem;
      color: var(--cream);
      min-width: 32px;
      text-align: right;
      font-weight: 500;
    }

    /* Toggle Buttons */
    .toggle-group {
      display: flex;
      background: var(--bg-deep);
      border-radius: 6px;
      padding: 3px;
      gap: 3px;
      box-shadow: inset 0 2px 6px rgba(0,0,0,0.4);
    }

    .toggle-btn {
      padding: 0.5rem 0.7rem;
      border: none;
      background: transparent;
      color: var(--cream-dim);
      font-family: 'DM Mono', monospace;
      font-size: 0.65rem;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s ease;
      letter-spacing: 0.03em;
    }

    .toggle-btn:hover { color: var(--cream); }

    .toggle-btn.active {
      color: var(--cream);
      font-weight: 500;
    }

    .toggle-btn.active[data-group="3"] {
      background: var(--group-3);
      box-shadow: 0 2px 8px rgba(74, 158, 140, 0.4);
    }

    .toggle-btn.active[data-group="4"] {
      background: var(--group-4);
      box-shadow: 0 2px 8px rgba(158, 107, 74, 0.4);
    }

    .toggle-btn.active[data-group="both"] {
      background: var(--group-both);
      box-shadow: 0 2px 8px rgba(138, 122, 158, 0.4);
    }

    /* Sound Selector */
    .sound-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      flex: 1;
    }

    .sound-btn {
      padding: 0.4rem 0.6rem;
      border: 1px solid var(--wood-mid);
      background: var(--bg-deep);
      color: var(--cream-dim);
      font-family: 'DM Mono', monospace;
      font-size: 0.55rem;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .sound-btn:hover {
      border-color: var(--accent-gold);
      color: var(--cream);
    }

    .sound-btn.active {
      background: var(--wood-mid);
      border-color: var(--accent-gold);
      color: var(--cream);
    }

    /* Charleston Toggle */
    .charleston-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .toggle-switch {
      position: relative;
      width: 40px;
      height: 22px;
      background: var(--bg-deep);
      border-radius: 11px;
      cursor: pointer;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
      transition: background 0.2s ease;
    }

    .toggle-switch.active {
      background: var(--charleston);
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 16px;
      height: 16px;
      background: var(--cream);
      border-radius: 50%;
      transition: transform 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .toggle-switch.active::after {
      transform: translateX(18px);
    }

    .toggle-label {
      font-size: 0.65rem;
      color: var(--cream-dim);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .toggle-switch.active + .toggle-label {
      color: var(--charleston);
    }

    /* Swing Knob */
    .knob-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.3rem;
    }

    .knob {
      position: relative;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background:
        radial-gradient(circle at 30% 30%, var(--wood-light), var(--wood-mid) 60%, #4a3a32);
      box-shadow:
        0 4px 12px rgba(0,0,0,0.4),
        inset 0 2px 4px rgba(255,255,255,0.1);
      cursor: pointer;
      user-select: none;
    }

    .knob::before {
      content: '';
      position: absolute;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      width: 3px;
      height: 12px;
      background: var(--accent-gold);
      border-radius: 2px;
      box-shadow: 0 0 6px var(--accent-gold);
    }

    .knob-label {
      font-size: 0.55rem;
      color: var(--cream-dim);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .knob-value {
      font-size: 0.7rem;
      color: var(--cream);
      font-weight: 500;
    }

    /* Pattern indicator */
    .pattern-display {
      display: flex;
      justify-content: center;
      gap: 2px;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--wood-mid);
    }

    .pattern-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: var(--bg-deep);
      border: 1px solid var(--wood-mid);
      transition: all 0.1s ease;
    }

    .pattern-dot.hit {
      background: var(--wood-light);
      border-color: var(--accent-gold);
    }

    .pattern-dot.charleston {
      border-color: var(--charleston);
    }

    .pattern-dot.active {
      background: var(--accent-orange);
      border-color: var(--accent-ember);
      box-shadow: 0 0 6px var(--hit-glow);
    }

    .pattern-dot.group-start {
      margin-left: 5px;
    }

    .pattern-dot:first-child {
      margin-left: 0;
    }

    /* Footer */
    footer {
      margin-top: 1.5rem;
      text-align: center;
      font-size: 0.6rem;
      color: var(--cream-dim);
      opacity: 0.6;
    }

    footer span {
      color: var(--accent-gold);
    }

    /* Start prompt overlay */
    .start-prompt {
      position: fixed;
      inset: 0;
      background: rgba(26, 20, 16, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      cursor: pointer;
      transition: opacity 0.4s ease;
    }

    .start-prompt.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .start-prompt-content {
      text-align: center;
    }

    .start-prompt h2 {
      font-family: 'Instrument Serif', serif;
      font-size: 2rem;
      font-style: italic;
      color: var(--cream);
      margin-bottom: 1rem;
    }

    .start-prompt p {
      color: var(--cream-dim);
      font-size: 0.8rem;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    /* Disabled state for charleston controls */
    .charleston-controls {
      transition: opacity 0.3s ease;
    }

    .charleston-controls.disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    /* Recording UI */
    .record-section {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px dashed rgba(107, 83, 68, 0.4);
    }

    .record-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--bg-deep);
      border: 2px solid #c44;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .record-btn:hover {
      background: rgba(204, 68, 68, 0.2);
      border-color: #e55;
    }

    .record-btn .record-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #c44;
      transition: all 0.2s ease;
    }

    .record-btn.recording {
      border-color: #f55;
      animation: record-pulse 1s ease-in-out infinite;
    }

    .record-btn.recording .record-dot {
      background: #f55;
      border-radius: 3px;
      width: 12px;
      height: 12px;
    }

    @keyframes record-pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(255, 85, 85, 0.4); }
      50% { box-shadow: 0 0 0 8px rgba(255, 85, 85, 0); }
    }

    .record-btn.has-recording {
      border-color: var(--group-3);
    }

    .record-btn.has-recording .record-dot {
      background: var(--group-3);
    }

    .record-status {
      flex: 1;
      font-size: 0.6rem;
      color: var(--cream-dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .record-status.recording {
      color: #f55;
    }

    .record-status.has-recording {
      color: var(--group-3);
    }

    .record-status .cycle-count {
      font-weight: 500;
      color: var(--cream);
    }

    .use-recording-toggle {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .use-recording-toggle.disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    .clear-recording-btn {
      padding: 0.3rem 0.5rem;
      background: transparent;
      border: 1px solid var(--wood-mid);
      color: var(--cream-dim);
      font-family: 'DM Mono', monospace;
      font-size: 0.5rem;
      cursor: pointer;
      border-radius: 3px;
      text-transform: uppercase;
      transition: all 0.2s ease;
    }

    .clear-recording-btn:hover {
      border-color: #c44;
      color: #c44;
    }

    .clear-recording-btn.disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    /* Count-in overlay */
    .count-in-overlay {
      position: fixed;
      inset: 0;
      background: rgba(26, 20, 16, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .count-in-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }

    .count-in-display {
      font-family: 'Instrument Serif', serif;
      font-size: 8rem;
      font-style: italic;
      color: var(--cream);
      text-shadow: 0 0 60px rgba(255, 170, 51, 0.6);
    }

    .count-in-display.recording-active {
      color: #f55;
      text-shadow: 0 0 60px rgba(255, 85, 85, 0.6);
    }

    /* Beat progress indicator */
    .beat-progress {
      display: flex;
      gap: 8px;
      margin-top: 2rem;
    }

    .beat-progress .beat-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--bg-panel);
      border: 2px solid var(--wood-mid);
      transition: all 0.1s ease;
    }

    .beat-progress .beat-dot.active {
      background: var(--accent-gold);
      border-color: var(--accent-gold);
      box-shadow: 0 0 12px var(--accent-gold);
    }

    .beat-progress .beat-dot.downbeat {
      width: 20px;
      height: 20px;
    }

    .count-in-overlay.recording-active .beat-progress .beat-dot.active {
      background: #f55;
      border-color: #f55;
      box-shadow: 0 0 12px #f55;
    }

    /* Metro toggle */
    .metro-toggle {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .metro-toggle .toggle-switch.active {
      background: var(--accent-gold);
    }

    /* Record controls row */
    .record-controls {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      margin-top: 0.5rem;
      flex-wrap: wrap;
    }

    .save-recording-btn {
      padding: 0.3rem 0.5rem;
      background: transparent;
      border: 1px solid var(--group-3);
      color: var(--group-3);
      font-family: 'DM Mono', monospace;
      font-size: 0.5rem;
      cursor: pointer;
      border-radius: 3px;
      text-transform: uppercase;
      transition: all 0.2s ease;
    }

    .save-recording-btn:hover {
      background: rgba(74, 158, 140, 0.2);
    }

    .save-recording-btn.disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    .solo-toggle {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .solo-toggle.disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    .solo-toggle .toggle-switch.active {
      background: var(--accent-orange);
    }

    .saved-recordings-select {
      padding: 0.35rem 0.5rem;
      background: var(--bg-deep);
      border: 1px solid var(--wood-mid);
      color: var(--cream);
      font-family: 'DM Mono', monospace;
      font-size: 0.55rem;
      border-radius: 4px;
      cursor: pointer;
      min-width: 80px;
    }

    .saved-recordings-select:focus {
      outline: none;
      border-color: var(--accent-gold);
    }

    .saved-recordings-select.disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    .saved-recordings-select option {
      background: var(--bg-panel);
      color: var(--cream);
    }
  </style>
</head>
<body>
  <div class="start-prompt" id="startPrompt">
    <div class="start-prompt-content">
      <h2>Bembe Bell Pattern</h2>
      <p>Click anywhere to begin</p>
    </div>
  </div>

  <div class="count-in-overlay" id="countInOverlay">
    <div class="count-in-display" id="countInDisplay">4</div>
    <div class="beat-progress" id="beatProgress">
      <div class="beat-dot"></div>
      <div class="beat-dot"></div>
      <div class="beat-dot"></div>
      <div class="beat-dot"></div>
      <div class="beat-dot"></div>
      <div class="beat-dot"></div>
      <div class="beat-dot"></div>
      <div class="beat-dot"></div>
      <div class="beat-dot"></div>
      <div class="beat-dot"></div>
      <div class="beat-dot"></div>
      <div class="beat-dot"></div>
    </div>
  </div>

  <div class="container">
    <header>
      <h1>Bembe</h1>
      <p class="subtitle">12/8 Bell Pattern Trainer</p>
    </header>

    <div class="sequencer-container">
      <div class="sequencer-ring"></div>
      <svg class="group-arcs" viewBox="0 0 304 304" id="groupArcs"></svg>
      <div id="beatMarkers"></div>
      <div class="center-display">
        <div class="tempo-display" id="tempoDisplay">90</div>
        <div class="tempo-label">BPM</div>
      </div>
    </div>

    <div class="controls">
      <!-- Transport & Tempo -->
      <div class="control-section">
        <div class="control-row transport-row">
          <button class="play-btn" id="playBtn">
            <svg class="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
            <svg class="pause-icon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
          </button>
          <div class="slider-container">
            <span class="slider-bounds">60</span>
            <input type="range" class="slider" id="tempoSlider" min="60" max="160" value="90">
            <span class="slider-bounds">160</span>
          </div>
          <div class="knobs-group">
            <div class="knob-container">
              <div class="knob" id="swingKnob" title="Drag to adjust swing"></div>
              <span class="knob-label">Swing</span>
              <span class="knob-value" id="swingValue">0%</span>
            </div>
            <div class="knob-container">
              <div class="knob" id="humanizeKnob" title="Drag to adjust humanization"></div>
              <span class="knob-label">Human</span>
              <span class="knob-value" id="humanizeValue">0%</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Grouping -->
      <div class="control-section">
        <div class="section-header">Pulse Grouping</div>
        <div class="control-row">
          <span class="control-label">Feel</span>
          <div class="toggle-group">
            <button class="toggle-btn active" data-group="3">3+3+3+3</button>
            <button class="toggle-btn" data-group="4">4+4+4</button>
            <button class="toggle-btn" data-group="both">Both</button>
          </div>
        </div>
        <div class="control-row">
          <span class="control-label">Sound</span>
          <div class="sound-selector" id="pulseSoundSelector">
            <button class="sound-btn active" data-sound="kick">Kick</button>
            <button class="sound-btn" data-sound="tom-low">Tom Lo</button>
            <button class="sound-btn" data-sound="conga">Conga</button>
            <button class="sound-btn" data-sound="shaker">Click</button>
          </div>
        </div>
      </div>

      <!-- Bell Pattern -->
      <div class="control-section">
        <div class="section-header">Bell Pattern</div>
        <div class="control-row">
          <span class="control-label">Sound</span>
          <div class="sound-selector" id="bellSoundSelector">
            <button class="sound-btn active" data-sound="agogo-high">Agogo Hi</button>
            <button class="sound-btn" data-sound="agogo-low">Agogo Lo</button>
            <button class="sound-btn" data-sound="cowbell">Cowbell</button>
            <button class="sound-btn" data-sound="clave">Clave</button>
            <button class="sound-btn" data-sound="woodblock">Wood</button>
          </div>
        </div>
        <div class="record-section">
          <button class="record-btn" id="recordBtn" title="Record your own bell pattern">
            <div class="record-dot"></div>
          </button>
          <div class="record-status" id="recordStatus">
            Record 4 cycles at current tempo
          </div>
          <div class="metro-toggle" id="metroToggle" title="Metronome click during recording">
            <div class="toggle-switch active" id="metroSwitch"></div>
            <span class="toggle-label">Metro</span>
          </div>
          <button class="save-recording-btn disabled" id="saveRecordingBtn">Save</button>
        </div>
        <div class="record-controls">
          <div class="use-recording-toggle disabled" id="useRecordingToggle">
            <div class="toggle-switch" id="useRecordingSwitch"></div>
            <span class="toggle-label">Use</span>
          </div>
          <div class="solo-toggle disabled" id="soloToggle">
            <div class="toggle-switch" id="soloSwitch"></div>
            <span class="toggle-label">Solo</span>
          </div>
          <select class="saved-recordings-select disabled" id="savedRecordingsSelect">
            <option value="-1">Current</option>
          </select>
          <button class="clear-recording-btn disabled" id="clearRecordingBtn">Clear</button>
        </div>
      </div>

      <!-- Charleston -->
      <div class="control-section">
        <div class="section-header">Charleston</div>
        <div class="control-row">
          <div class="charleston-toggle">
            <div class="toggle-switch" id="charlestonToggle"></div>
            <span class="toggle-label">Enable</span>
          </div>
        </div>
        <div class="control-row charleston-controls disabled" id="charlestonControls">
          <span class="control-label">Sound</span>
          <div class="sound-selector" id="charlestonSoundSelector">
            <button class="sound-btn active" data-sound="hihat-closed">HiHat</button>
            <button class="sound-btn" data-sound="ride">Ride</button>
            <button class="sound-btn" data-sound="tambourine">Tamb</button>
            <button class="sound-btn" data-sound="shaker">Shaker</button>
          </div>
        </div>
      </div>

      <div class="pattern-display" id="patternDisplay"></div>
    </div>

    <footer>Traditional <span>West African</span> rhythm pattern</footer>
  </div>

  <script>
    // Patterns
    const BEMBE_PATTERN = [1,0,1,0,1,1,0,1,0,1,0,1];  // X.X.XX.X.X.X
    const CHARLESTON_PATTERN = [1,0,0,0,0,1,0,0,0,1,0,0];  // Charleston in 12/8: beats 1, 6, 10
    const TOTAL_BEATS = 12;

    // State
    let isPlaying = false;
    let currentBeat = -1;
    let tempo = 90;
    let swing = 0;
    let humanize = 0;  // 0-1, controls timing jitter and velocity variation
    let grouping = '3';  // '3', '4', or 'both'
    let charlestonEnabled = false;
    let bellSound = 'agogo-high';
    let pulseSound = 'kick';
    let charlestonSound = 'hihat-closed';
    let loop = null;

    // Recording state
    let isRecording = false;
    let recordingTempo = 90;  // Tempo at which recording was made
    let recordedBuffer = null;  // AudioBuffer of recorded audio
    let grainPlayer = null;  // Tone.GrainPlayer for time-stretched playback
    let useRecording = false;  // Whether to use recorded sample instead of synth
    let soloRecording = false;  // Mute all synth sounds when true
    let metronomeOn = true;  // Play click track during recording
    let mediaRecorder = null;
    let recordedChunks = [];
    const RECORD_CYCLES = 4;  // Number of cycles to record

    // Saved recordings (in-memory session storage)
    let savedRecordings = [];  // Array of { buffer, tempo, timestamp, name }
    let currentRecordingIndex = -1;  // Index of currently selected saved recording

    // DOM elements
    const startPrompt = document.getElementById('startPrompt');
    const playBtn = document.getElementById('playBtn');
    const tempoSlider = document.getElementById('tempoSlider');
    const tempoDisplay = document.getElementById('tempoDisplay');
    const swingKnob = document.getElementById('swingKnob');
    const swingValue = document.getElementById('swingValue');
    const humanizeKnob = document.getElementById('humanizeKnob');
    const humanizeValue = document.getElementById('humanizeValue');
    const beatMarkersContainer = document.getElementById('beatMarkers');
    const groupArcs = document.getElementById('groupArcs');
    const patternDisplay = document.getElementById('patternDisplay');
    const charlestonToggle = document.getElementById('charlestonToggle');
    const charlestonControls = document.getElementById('charlestonControls');

    // Recording DOM elements
    const countInOverlay = document.getElementById('countInOverlay');
    const countInDisplay = document.getElementById('countInDisplay');
    const beatProgress = document.getElementById('beatProgress');
    const beatDots = beatProgress.querySelectorAll('.beat-dot');
    const recordBtn = document.getElementById('recordBtn');
    const recordStatus = document.getElementById('recordStatus');
    const metroSwitch = document.getElementById('metroSwitch');
    const useRecordingToggle = document.getElementById('useRecordingToggle');
    const useRecordingSwitch = document.getElementById('useRecordingSwitch');
    const soloToggle = document.getElementById('soloToggle');
    const soloSwitch = document.getElementById('soloSwitch');
    const saveRecordingBtn = document.getElementById('saveRecordingBtn');
    const savedRecordingsSelect = document.getElementById('savedRecordingsSelect');
    const clearRecordingBtn = document.getElementById('clearRecordingBtn');

    // Sound definitions
    const soundFactories = {
      // Bell sounds
      'agogo-high': () => {
        const synth = new Tone.MetalSynth({
          frequency: 880, envelope: { attack: 0.001, decay: 0.15, release: 0.1 },
          harmonicity: 5.1, modulationIndex: 20, resonance: 4000, octaves: 1.5
        }).toDestination();
        synth.volume.value = -8;
        return { synth, note: 'C6' };
      },
      'agogo-low': () => {
        const synth = new Tone.MetalSynth({
          frequency: 587, envelope: { attack: 0.001, decay: 0.18, release: 0.12 },
          harmonicity: 4.1, modulationIndex: 18, resonance: 3000, octaves: 1.3
        }).toDestination();
        synth.volume.value = -6;
        return { synth, note: 'G4' };
      },
      'cowbell': () => {
        const synth = new Tone.MetalSynth({
          frequency: 560, envelope: { attack: 0.001, decay: 0.2, release: 0.15 },
          harmonicity: 6, modulationIndex: 32, resonance: 2500, octaves: 0.8
        }).toDestination();
        synth.volume.value = -10;
        return { synth, note: 'C5' };
      },
      'clave': () => {
        const synth = new Tone.MembraneSynth({
          pitchDecay: 0.008, octaves: 4, oscillator: { type: 'sine' },
          envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.04 }
        }).toDestination();
        synth.volume.value = -4;
        return { synth, note: 'C5' };
      },
      'woodblock': () => {
        const synth = new Tone.MembraneSynth({
          pitchDecay: 0.01, octaves: 6, oscillator: { type: 'triangle' },
          envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 }
        }).toDestination();
        synth.volume.value = -2;
        return { synth, note: 'G5' };
      },
      // Pulse sounds
      'kick': () => {
        const synth = new Tone.MembraneSynth({
          pitchDecay: 0.05, octaves: 4, oscillator: { type: 'sine' },
          envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 }
        }).toDestination();
        synth.volume.value = -8;
        return { synth, note: 'C1' };
      },
      'tom-low': () => {
        const synth = new Tone.MembraneSynth({
          pitchDecay: 0.03, octaves: 3, oscillator: { type: 'sine' },
          envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.1 }
        }).toDestination();
        synth.volume.value = -6;
        return { synth, note: 'G2' };
      },
      'conga': () => {
        const synth = new Tone.MembraneSynth({
          pitchDecay: 0.02, octaves: 2.5, oscillator: { type: 'sine' },
          envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.08 }
        }).toDestination();
        synth.volume.value = -4;
        return { synth, note: 'C3' };
      },
      'shaker': () => {
        const synth = new Tone.NoiseSynth({
          noise: { type: 'white' },
          envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.02 }
        }).toDestination();
        synth.volume.value = -12;
        return { synth, note: null };
      },
      // Charleston sounds
      'hihat-closed': () => {
        const synth = new Tone.MetalSynth({
          frequency: 400, envelope: { attack: 0.001, decay: 0.05, release: 0.01 },
          harmonicity: 5.1, modulationIndex: 40, resonance: 8000, octaves: 1
        }).toDestination();
        synth.volume.value = -14;
        return { synth, note: 'C6' };
      },
      'ride': () => {
        const synth = new Tone.MetalSynth({
          frequency: 300, envelope: { attack: 0.001, decay: 0.4, release: 0.2 },
          harmonicity: 12, modulationIndex: 20, resonance: 5000, octaves: 0.5
        }).toDestination();
        synth.volume.value = -12;
        return { synth, note: 'C5' };
      },
      'tambourine': () => {
        const synth = new Tone.MetalSynth({
          frequency: 800, envelope: { attack: 0.001, decay: 0.1, release: 0.05 },
          harmonicity: 8, modulationIndex: 30, resonance: 6000, octaves: 1.2
        }).toDestination();
        synth.volume.value = -10;
        return { synth, note: 'C6' };
      }
    };

    // Synth instances
    let bellSynthData = soundFactories[bellSound]();
    let pulse3SynthData = soundFactories[pulseSound]();
    let pulse4SynthData = soundFactories[pulseSound]();
    let charlestonSynthData = soundFactories[charlestonSound]();

    function clearChildren(element) {
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }

    function createBeatMarkers() {
      clearChildren(beatMarkersContainer);
      const container = document.querySelector('.sequencer-container');
      const size = container.offsetWidth;
      const centerX = size / 2;
      const centerY = size / 2;
      const radius = size * 0.375; // 105/280 ≈ 0.375

      for (let i = 0; i < TOTAL_BEATS; i++) {
        const angle = (i / TOTAL_BEATS) * 2 * Math.PI - Math.PI / 2;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);

        const marker = document.createElement('div');
        marker.className = 'beat-marker';
        marker.dataset.beat = String(i);
        marker.style.left = x + 'px';
        marker.style.top = y + 'px';
        marker.textContent = String(i + 1);

        if (BEMBE_PATTERN[i]) marker.classList.add('hit');
        if (charlestonEnabled && CHARLESTON_PATTERN[i]) marker.classList.add('charleston-hit');

        beatMarkersContainer.appendChild(marker);
      }
      updateAccentMarkers();
    }

    function updateAccentMarkers() {
      const markers = document.querySelectorAll('.beat-marker');
      markers.forEach((marker, i) => {
        marker.classList.remove('accent-3', 'accent-4', 'charleston-hit');

        if (grouping === '3' || grouping === 'both') {
          if (i % 3 === 0) marker.classList.add('accent-3');
        }
        if (grouping === '4' || grouping === 'both') {
          if (i % 4 === 0) marker.classList.add('accent-4');
        }
        if (charlestonEnabled && CHARLESTON_PATTERN[i]) {
          marker.classList.add('charleston-hit');
        }
      });
      drawGroupArcs();
      createPatternDisplay();
    }

    function drawGroupArcs() {
      clearChildren(groupArcs);
      const container = document.querySelector('.sequencer-container');
      const size = container.offsetWidth;
      // SVG viewBox is 304x304, container is 280px + 12px inset on each side = 304
      // Scale factor: SVG coordinates relative to container
      const svgSize = size + 24; // account for inset: -12px
      const centerX = svgSize / 2;
      const centerY = svgSize / 2;

      // Update SVG viewBox to match
      groupArcs.setAttribute('viewBox', '0 0 ' + svgSize + ' ' + svgSize);

      function drawArcSet(groupSize, radiusRatio, className) {
        const radius = size * radiusRatio;
        const numGroups = TOTAL_BEATS / groupSize;
        for (let g = 0; g < numGroups; g++) {
          const startAngle = (g * groupSize / TOTAL_BEATS) * 2 * Math.PI - Math.PI / 2;
          const endAngle = ((g + 1) * groupSize / TOTAL_BEATS) * 2 * Math.PI - Math.PI / 2 - 0.08;
          const startX = centerX + radius * Math.cos(startAngle);
          const startY = centerY + radius * Math.sin(startAngle);
          const endX = centerX + radius * Math.cos(endAngle);
          const endY = centerY + radius * Math.sin(endAngle);
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', 'M ' + startX + ' ' + startY + ' A ' + radius + ' ' + radius + ' 0 0 1 ' + endX + ' ' + endY);
          path.setAttribute('class', 'group-arc ' + className);
          groupArcs.appendChild(path);
        }
      }

      if (grouping === '3' || grouping === 'both') {
        drawArcSet(3, 0.48, 'group-3'); // 135/280 ≈ 0.48
      }
      if (grouping === '4' || grouping === 'both') {
        drawArcSet(4, grouping === 'both' ? 0.52 : 0.48, 'group-4'); // 145/280 ≈ 0.52
      }
    }

    function createPatternDisplay() {
      clearChildren(patternDisplay);
      const displayGrouping = grouping === 'both' ? 3 : parseInt(grouping);

      for (let i = 0; i < TOTAL_BEATS; i++) {
        const dot = document.createElement('div');
        dot.className = 'pattern-dot';
        dot.dataset.beat = String(i);
        if (BEMBE_PATTERN[i]) dot.classList.add('hit');
        if (charlestonEnabled && CHARLESTON_PATTERN[i]) dot.classList.add('charleston');
        if (i > 0 && i % displayGrouping === 0) dot.classList.add('group-start');
        patternDisplay.appendChild(dot);
      }
    }

    function updateVisuals(beat) {
      document.querySelectorAll('.beat-marker').forEach((marker, i) => {
        marker.classList.toggle('active', i === beat);
      });
      document.querySelectorAll('.pattern-dot').forEach((dot, i) => {
        dot.classList.toggle('active', i === beat);
      });
    }

    // Humanization helpers
    function getTimingJitter() {
      // Returns timing offset in seconds, ±0-25ms based on humanize amount
      const maxJitterMs = 25;
      const jitterMs = (Math.random() * 2 - 1) * maxJitterMs * humanize;
      return jitterMs / 1000;
    }

    function getVelocityVariation() {
      // Returns volume offset in dB, ±0-6dB based on humanize amount
      const maxVariationDb = 6;
      return (Math.random() * 2 - 1) * maxVariationDb * humanize;
    }

    function triggerSound(synthData, duration, time) {
      // Apply humanization
      const timingOffset = getTimingJitter();
      const velocityOffset = getVelocityVariation();

      // Store original volume and apply variation
      const originalVolume = synthData.synth.volume.value;
      synthData.synth.volume.value = originalVolume + velocityOffset;

      // Schedule the sound with timing offset
      const triggerTime = Math.max(0, time + timingOffset);

      if (synthData.note) {
        synthData.synth.triggerAttackRelease(synthData.note, duration, triggerTime);
      } else {
        synthData.synth.triggerAttackRelease(duration, triggerTime);
      }

      // Reset volume after a short delay (don't affect next hit)
      setTimeout(() => {
        synthData.synth.volume.value = originalVolume;
      }, 50);
    }

    function playBeat(beat, time) {
      // Skip all synth sounds if solo mode is enabled with recording
      const muteAllSynths = useRecording && soloRecording;

      // Pulse accents
      if (!muteAllSynths) {
        if (grouping === '3' || grouping === 'both') {
          if (beat % 3 === 0) triggerSound(pulse3SynthData, '16n', time);
        }
        if (grouping === '4' || grouping === 'both') {
          if (beat % 4 === 0) triggerSound(pulse4SynthData, '16n', time);
        }
      }

      // Bell pattern (skip if using recorded sample)
      if (BEMBE_PATTERN[beat] && !useRecording) {
        triggerSound(bellSynthData, '32n', time);
      }

      // Charleston
      if (!muteAllSynths && charlestonEnabled && CHARLESTON_PATTERN[beat]) {
        triggerSound(charlestonSynthData, '16n', time);
      }
    }

    function togglePlay() {
      if (isPlaying) {
        Tone.Transport.stop();
        Tone.Transport.cancel();
        // Stop grain player if using recording
        if (useRecording && grainPlayer) {
          grainPlayer.stop();
        }
        isPlaying = false;
        playBtn.classList.remove('playing');
        currentBeat = -1;
        updateVisuals(-1);
      } else {
        let beatIndex = 0;
        Tone.Transport.bpm.value = tempo;
        Tone.Transport.swing = swing;
        Tone.Transport.swingSubdivision = '8n';

        loop = new Tone.Loop((time) => {
          const currentIndex = beatIndex;
          // Schedule audio with the precise time (includes humanization)
          playBeat(currentIndex, time);
          // Schedule visuals separately (no humanization offset for visuals)
          Tone.Draw.schedule(() => {
            currentBeat = currentIndex;
            updateVisuals(currentIndex);
          }, time);
          beatIndex = (beatIndex + 1) % TOTAL_BEATS;
        }, '8n');

        loop.start(0);
        Tone.Transport.start();
        // Start grain player if using recording
        if (useRecording && grainPlayer) {
          grainPlayer.start();
        }
        isPlaying = true;
        playBtn.classList.add('playing');
      }
    }

    function updateSound(type, soundName) {
      if (type === 'bell') {
        bellSound = soundName;
        bellSynthData.synth.dispose();
        bellSynthData = soundFactories[soundName]();
      } else if (type === 'pulse') {
        pulseSound = soundName;
        pulse3SynthData.synth.dispose();
        pulse4SynthData.synth.dispose();
        pulse3SynthData = soundFactories[soundName]();
        pulse4SynthData = soundFactories[soundName]();
      } else if (type === 'charleston') {
        charlestonSound = soundName;
        charlestonSynthData.synth.dispose();
        charlestonSynthData = soundFactories[soundName]();
      }
    }

    function changeGrouping(newGrouping) {
      grouping = newGrouping;
      updateAccentMarkers();
      document.querySelectorAll('.toggle-group .toggle-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.group === newGrouping);
      });
    }

    function changeTempo(newTempo) {
      tempo = newTempo;
      tempoDisplay.textContent = String(tempo);
      Tone.Transport.bpm.value = tempo;
      // Update grain player rate for tempo-matched playback
      updateGrainPlayerRate();
    }

    function changeSwing(newSwing) {
      swing = newSwing;
      swingValue.textContent = Math.round(newSwing * 100) + '%';
      Tone.Transport.swing = newSwing;
      // Rotate knob
      const rotation = -135 + (newSwing * 270);
      swingKnob.style.transform = 'rotate(' + rotation + 'deg)';
    }

    function changeHumanize(newHumanize) {
      humanize = newHumanize;
      humanizeValue.textContent = Math.round(newHumanize * 100) + '%';
      // Rotate knob
      const rotation = -135 + (newHumanize * 270);
      humanizeKnob.style.transform = 'rotate(' + rotation + 'deg)';
    }

    function toggleCharleston() {
      charlestonEnabled = !charlestonEnabled;
      charlestonToggle.classList.toggle('active', charlestonEnabled);
      charlestonControls.classList.toggle('disabled', !charlestonEnabled);
      updateAccentMarkers();
    }

    // ===== RECORDING FUNCTIONS =====

    // Toggle metronome click mode
    function toggleMetronome() {
      metronomeOn = !metronomeOn;
      metroSwitch.classList.toggle('active', metronomeOn);
    }

    // Update visual beat progress (0-11 for 12 beats)
    function updateBeatProgress(beatIndex) {
      beatDots.forEach((dot, i) => {
        dot.classList.toggle('active', i === beatIndex);
        dot.classList.toggle('downbeat', i % 3 === 0);
      });
    }

    // Reset beat progress
    function resetBeatProgress() {
      beatDots.forEach(dot => {
        dot.classList.remove('active');
        dot.classList.add('downbeat');
      });
      // Mark downbeats
      beatDots.forEach((dot, i) => {
        dot.classList.toggle('downbeat', i % 3 === 0);
      });
    }

    // Calculate duration of one cycle in seconds at given tempo
    function getCycleDuration(bpm) {
      // 12 eighth notes per cycle, tempo is in quarter notes per minute
      // 1 quarter = 2 eighths, so 12 eighths = 6 quarters
      // Duration = 6 quarters * (60 / bpm) seconds
      return (6 * 60) / bpm;
    }

    // Start recording process with count-in
    async function startRecording() {
      if (isRecording) return;

      // Stop playback if running
      if (isPlaying) {
        togglePlay();
      }

      // Request microphone permission
      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (err) {
        recordStatus.textContent = 'Microphone access denied';
        return;
      }

      recordingTempo = tempo;
      recordedChunks = [];

      // Set up MediaRecorder
      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          recordedChunks.push(e.data);
        }
      };
      mediaRecorder.onstop = () => {
        stream.getTracks().forEach(track => track.stop());
        processRecording();
      };

      // Start count-in
      await doCountIn();

      // Start recording
      isRecording = true;
      recordBtn.classList.add('recording');
      recordStatus.classList.add('recording');
      countInDisplay.classList.add('recording-active');

      mediaRecorder.start();

      // Record for the duration of RECORD_CYCLES cycles
      const cycleDuration = getCycleDuration(recordingTempo);
      const totalDuration = cycleDuration * RECORD_CYCLES * 1000; // in ms

      // Show cycle 1 immediately
      countInDisplay.textContent = '1';
      recordStatus.textContent = 'Recording cycle 1 of ' + RECORD_CYCLES + '...';

      // Schedule cycle count updates using Tone.Transport for accurate timing
      // Each cycle is 12 eighth notes, we schedule updates at the start of each cycle
      for (let cycle = 2; cycle <= RECORD_CYCLES; cycle++) {
        const cycleStartBeats = (cycle - 1) * 12; // Which eighth note this cycle starts on
        Tone.Transport.scheduleOnce((time) => {
          Tone.Draw.schedule(() => {
            countInDisplay.textContent = String(cycle);
            recordStatus.textContent = 'Recording cycle ' + cycle + ' of ' + RECORD_CYCLES + '...';
          }, time);
        }, { '8n': cycleStartBeats });
      }

      // Play click track during recording
      startClickTrack();

      // Schedule recording stop
      const totalBeats = RECORD_CYCLES * 12;
      Tone.Transport.scheduleOnce(() => {
        stopRecording();
      }, { '8n': totalBeats });
    }

    // Count-in before recording using Tone.Transport for accurate timing
    // Counts 1-2-3-4 where each number lasts 3 eighth notes (one cycle in 12/8)
    function doCountIn() {
      return new Promise((resolve) => {
        countInOverlay.classList.add('active');
        countInDisplay.classList.remove('recording-active');
        resetBeatProgress();

        const countInBeats = 12; // One full cycle count-in (4 counts x 3 eighth notes each)
        let beat = 0;

        // Click synth for count-in (only used if metronome is on)
        let clickSynth = null;
        if (metronomeOn) {
          clickSynth = new Tone.MembraneSynth({
            pitchDecay: 0.01,
            octaves: 4,
            oscillator: { type: 'sine' },
            envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 }
          }).toDestination();
          clickSynth.volume.value = -6;
        }

        // Use Tone.Transport for precise timing
        Tone.Transport.bpm.value = tempo;
        Tone.Transport.cancel();

        const countInLoop = new Tone.Loop((time) => {
          // Stop if we've already processed all beats
          if (beat >= countInBeats) {
            countInLoop.stop();
            return;
          }

          // Display count 1-2-3-4, each lasting 3 eighth notes
          const displayCount = Math.floor(beat / 3) + 1;
          const isDownbeat = (beat % 3 === 0);
          const currentBeat = beat;

          // Schedule visual updates
          Tone.Draw.schedule(() => {
            updateBeatProgress(currentBeat % 12);
            if (isDownbeat) {
              countInDisplay.textContent = String(displayCount);
            }
          }, time);

          // Play click sounds (if not silent)
          if (clickSynth) {
            if (isDownbeat) {
              clickSynth.triggerAttackRelease('G3', '16n', time);
            } else {
              clickSynth.triggerAttackRelease('C3', '32n', time);
            }
          }

          beat++;
          if (beat >= countInBeats) {
            // Schedule cleanup and resolve after the last beat plays
            Tone.Transport.scheduleOnce(() => {
              countInLoop.dispose();
              Tone.Transport.stop();
              Tone.Transport.cancel();
              if (clickSynth) clickSynth.dispose();
              resolve();
            }, '+8n');
          }
        }, '8n');

        countInLoop.start(0);
        Tone.Transport.start();
      });
    }

    // Click track during recording
    let clickTrackLoop = null;
    let clickTrackSynth = null;
    function startClickTrack() {
      // Only create synth if metronome is on
      if (metronomeOn) {
        clickTrackSynth = new Tone.MembraneSynth({
          pitchDecay: 0.01,
          octaves: 4,
          oscillator: { type: 'sine' },
          envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.04 }
        }).toDestination();
        clickTrackSynth.volume.value = -10;
      }

      Tone.Transport.bpm.value = recordingTempo;
      let beatIndex = 0;

      clickTrackLoop = new Tone.Loop((time) => {
        const beat = beatIndex % 12;
        const currentBeat = beat;

        // Always update visual progress
        Tone.Draw.schedule(() => {
          updateBeatProgress(currentBeat);
        }, time);

        // Play click sounds (if not silent)
        if (clickTrackSynth) {
          if (beat === 0) {
            clickTrackSynth.triggerAttackRelease('G3', '16n', time);
          } else if (beat % 3 === 0) {
            clickTrackSynth.triggerAttackRelease('E3', '32n', time);
          }
        }
        beatIndex++;
      }, '8n');

      clickTrackLoop.start(0);
      Tone.Transport.start();
    }

    function stopClickTrack() {
      if (clickTrackLoop) {
        clickTrackLoop.stop();
        clickTrackLoop.dispose();
        clickTrackLoop = null;
      }
      if (clickTrackSynth) {
        clickTrackSynth.dispose();
        clickTrackSynth = null;
      }
      Tone.Transport.stop();
      Tone.Transport.cancel();
      resetBeatProgress();
    }

    // Stop recording
    function stopRecording() {
      if (!isRecording) return;

      isRecording = false;
      stopClickTrack();
      countInOverlay.classList.remove('active');

      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      recordBtn.classList.remove('recording');
      recordStatus.classList.remove('recording');
      recordStatus.textContent = 'Processing...';
    }

    // Process the recorded audio
    async function processRecording() {
      if (recordedChunks.length === 0) {
        recordStatus.textContent = 'Recording failed';
        return;
      }

      const blob = new Blob(recordedChunks, { type: 'audio/webm' });
      const arrayBuffer = await blob.arrayBuffer();

      try {
        // Decode audio data
        const audioContext = Tone.context.rawContext;
        recordedBuffer = await audioContext.decodeAudioData(arrayBuffer);

        // Create GrainPlayer for time-stretched playback
        createGrainPlayer();

        // Update UI
        recordBtn.classList.add('has-recording');
        recordStatus.classList.add('has-recording');
        recordStatus.textContent = 'Recorded ' + RECORD_CYCLES + ' cycles at ' + recordingTempo + ' BPM';
        useRecordingToggle.classList.remove('disabled');
        soloToggle.classList.remove('disabled');
        saveRecordingBtn.classList.remove('disabled');
        clearRecordingBtn.classList.remove('disabled');

        // Enable dropdown if there are saved recordings
        if (savedRecordings.length > 0) {
          savedRecordingsSelect.classList.remove('disabled');
        }

      } catch (err) {
        console.error('Error processing recording:', err);
        recordStatus.textContent = 'Error processing recording';
      }
    }

    // Create GrainPlayer from recorded buffer
    function createGrainPlayer() {
      if (grainPlayer) {
        grainPlayer.dispose();
      }

      // Create a Tone.js buffer from the recorded buffer
      const toneBuffer = new Tone.Buffer(recordedBuffer);

      grainPlayer = new Tone.GrainPlayer({
        url: toneBuffer,
        loop: true,
        grainSize: 0.1,
        overlap: 0.05,
        playbackRate: 1
      }).toDestination();

      grainPlayer.volume.value = -3;

      // Set playback rate based on tempo difference
      updateGrainPlayerRate();
    }

    // Update GrainPlayer playback rate when tempo changes
    function updateGrainPlayerRate() {
      if (grainPlayer && recordedBuffer) {
        // Playback rate = current tempo / recording tempo
        const rate = tempo / recordingTempo;
        grainPlayer.playbackRate = rate;
      }
    }

    // Toggle using recorded sample
    function toggleUseRecording() {
      if (!recordedBuffer) return;

      useRecording = !useRecording;
      useRecordingSwitch.classList.toggle('active', useRecording);

      if (useRecording && isPlaying) {
        // Start grain player synced to transport
        grainPlayer.start();
      } else if (!useRecording && grainPlayer) {
        grainPlayer.stop();
      }
    }

    // Toggle solo mode (mute all synths when using recording)
    function toggleSolo() {
      soloRecording = !soloRecording;
      soloSwitch.classList.toggle('active', soloRecording);
    }

    // Save current recording to session storage
    function saveRecording() {
      if (!recordedBuffer) return;

      const recording = {
        buffer: recordedBuffer,
        tempo: recordingTempo,
        timestamp: Date.now(),
        name: 'Take ' + (savedRecordings.length + 1) + ' (' + recordingTempo + ' BPM)'
      };

      savedRecordings.push(recording);
      currentRecordingIndex = savedRecordings.length - 1;

      // Update dropdown
      updateSavedRecordingsDropdown();
      savedRecordingsSelect.value = String(currentRecordingIndex);
      savedRecordingsSelect.classList.remove('disabled');
    }

    // Update the saved recordings dropdown
    function updateSavedRecordingsDropdown() {
      // Clear existing options except "Current"
      while (savedRecordingsSelect.options.length > 1) {
        savedRecordingsSelect.remove(1);
      }

      // Add saved recordings
      savedRecordings.forEach((rec, index) => {
        const option = document.createElement('option');
        option.value = String(index);
        option.textContent = rec.name;
        savedRecordingsSelect.appendChild(option);
      });
    }

    // Load a saved recording
    function loadSavedRecording(index) {
      if (index < 0 || index >= savedRecordings.length) {
        // "Current" selected - keep current recording
        currentRecordingIndex = -1;
        return;
      }

      const recording = savedRecordings[index];
      currentRecordingIndex = index;

      // Stop current playback if using recording
      if (useRecording && grainPlayer) {
        grainPlayer.stop();
      }

      // Load the saved recording
      recordedBuffer = recording.buffer;
      recordingTempo = recording.tempo;

      // Recreate grain player with saved buffer
      createGrainPlayer();

      // Update status
      recordStatus.textContent = recording.name;
      recordStatus.classList.add('has-recording');
      recordBtn.classList.add('has-recording');

      // Restart playback if it was playing
      if (useRecording && isPlaying && grainPlayer) {
        grainPlayer.start();
      }
    }

    // Clear recorded sample
    function clearRecording() {
      if (grainPlayer) {
        grainPlayer.stop();
        grainPlayer.dispose();
        grainPlayer = null;
      }
      recordedBuffer = null;
      useRecording = false;
      soloRecording = false;
      recordedChunks = [];
      currentRecordingIndex = -1;

      recordBtn.classList.remove('has-recording');
      recordStatus.classList.remove('has-recording');
      recordStatus.textContent = 'Record ' + RECORD_CYCLES + ' cycles at current tempo';
      useRecordingToggle.classList.add('disabled');
      useRecordingSwitch.classList.remove('active');
      soloToggle.classList.add('disabled');
      soloSwitch.classList.remove('active');
      saveRecordingBtn.classList.add('disabled');
      clearRecordingBtn.classList.add('disabled');

      // Reset dropdown to "Current" but keep saved recordings available
      savedRecordingsSelect.value = '-1';
    }

    // Toggle record button (start or stop)
    function toggleRecord() {
      if (isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    }

    // ===== END RECORDING FUNCTIONS =====

    // Event listeners
    startPrompt.addEventListener('click', async () => {
      await Tone.start();
      startPrompt.classList.add('hidden');
    });

    playBtn.addEventListener('click', togglePlay);

    tempoSlider.addEventListener('input', (e) => {
      changeTempo(parseInt(e.target.value));
    });

    // Swing knob drag
    let isDraggingKnob = false;
    let knobStartY = 0;
    let knobStartSwing = 0;

    swingKnob.addEventListener('mousedown', (e) => {
      isDraggingKnob = true;
      knobStartY = e.clientY;
      knobStartSwing = swing;
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDraggingKnob) return;
      const deltaY = knobStartY - e.clientY;
      const newSwing = Math.max(0, Math.min(1, knobStartSwing + deltaY / 150));
      changeSwing(newSwing);
    });

    document.addEventListener('mouseup', () => {
      isDraggingKnob = false;
    });

    // Touch support for knob
    swingKnob.addEventListener('touchstart', (e) => {
      isDraggingKnob = true;
      knobStartY = e.touches[0].clientY;
      knobStartSwing = swing;
      e.preventDefault();
    });

    document.addEventListener('touchmove', (e) => {
      if (!isDraggingKnob) return;
      const deltaY = knobStartY - e.touches[0].clientY;
      const newSwing = Math.max(0, Math.min(1, knobStartSwing + deltaY / 150));
      changeSwing(newSwing);
    });

    document.addEventListener('touchend', () => {
      isDraggingKnob = false;
      isDraggingHumanizeKnob = false;
    });

    // Humanize knob drag
    let isDraggingHumanizeKnob = false;
    let humanizeKnobStartY = 0;
    let humanizeKnobStartValue = 0;

    humanizeKnob.addEventListener('mousedown', (e) => {
      isDraggingHumanizeKnob = true;
      humanizeKnobStartY = e.clientY;
      humanizeKnobStartValue = humanize;
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (isDraggingHumanizeKnob) {
        const deltaY = humanizeKnobStartY - e.clientY;
        const newHumanize = Math.max(0, Math.min(1, humanizeKnobStartValue + deltaY / 150));
        changeHumanize(newHumanize);
      }
    });

    document.addEventListener('mouseup', () => {
      isDraggingHumanizeKnob = false;
    });

    humanizeKnob.addEventListener('touchstart', (e) => {
      isDraggingHumanizeKnob = true;
      humanizeKnobStartY = e.touches[0].clientY;
      humanizeKnobStartValue = humanize;
      e.preventDefault();
    });

    document.addEventListener('touchmove', (e) => {
      if (isDraggingHumanizeKnob) {
        const deltaY = humanizeKnobStartY - e.touches[0].clientY;
        const newHumanize = Math.max(0, Math.min(1, humanizeKnobStartValue + deltaY / 150));
        changeHumanize(newHumanize);
      }
    });

    // Grouping buttons
    document.querySelectorAll('.toggle-group .toggle-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        changeGrouping(btn.dataset.group);
      });
    });

    // Sound selectors
    document.querySelectorAll('#bellSoundSelector .sound-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        updateSound('bell', btn.dataset.sound);
        document.querySelectorAll('#bellSoundSelector .sound-btn').forEach(b =>
          b.classList.toggle('active', b === btn));
      });
    });

    document.querySelectorAll('#pulseSoundSelector .sound-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        updateSound('pulse', btn.dataset.sound);
        document.querySelectorAll('#pulseSoundSelector .sound-btn').forEach(b =>
          b.classList.toggle('active', b === btn));
      });
    });

    document.querySelectorAll('#charlestonSoundSelector .sound-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        updateSound('charleston', btn.dataset.sound);
        document.querySelectorAll('#charlestonSoundSelector .sound-btn').forEach(b =>
          b.classList.toggle('active', b === btn));
      });
    });

    charlestonToggle.addEventListener('click', toggleCharleston);

    // Recording controls
    recordBtn.addEventListener('click', toggleRecord);
    metroSwitch.addEventListener('click', toggleMetronome);
    useRecordingSwitch.addEventListener('click', toggleUseRecording);
    soloSwitch.addEventListener('click', toggleSolo);
    saveRecordingBtn.addEventListener('click', saveRecording);
    savedRecordingsSelect.addEventListener('change', (e) => {
      loadSavedRecording(parseInt(e.target.value));
    });
    clearRecordingBtn.addEventListener('click', clearRecording);

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (!startPrompt.classList.contains('hidden')) {
          Tone.start().then(() => startPrompt.classList.add('hidden'));
        } else {
          togglePlay();
        }
      }
    });

    // Handle window resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        createBeatMarkers();
      }, 100);
    });

    // Initialize
    createBeatMarkers();
    createPatternDisplay();
    changeSwing(0);
    changeHumanize(0);
  </script>
</body>
</html>
